# Rubyによるデザインパターン

**Rubyによるデザインパターン (著: ラス・オルセン）**という本のサンプル集です。

この本は、Gofの23のデザインパターンの14個をカバーしています。

* [テンプレートメソッド](#template-method)
* [ストラテジ](#strategy)
* [オブサーバー](#observer)
* [コンポジット](#composite)
* [Iterator](#iterator)
* [Commands](#commands)
* [Adapter](#adapter)
* [Proxy](#proxy)
* [Decorator](#decorator)
* [Singleton](#singleton)
* [Factory](#factory)
* [Builder](#builder)
* [Interpreter](#interpreter)


----------------------------------------------------------------

## デザインパターン

### テンプレートメソッド<a name="template-method"></a>

目的/概要:
  * アルゴリズムに多様性をもたせたい場合に便利
  * 基底クラスに不変の部分を記述し、変わる部分はサブクラスに定義するメソッドにカプセル化する

やり方:
  1. アルゴリズム間で骨格となるメソッド(**テンプレートメソッド**)を定義した**基底クラス**を作成する
     基底クラスのテンプレートメソッドは、サブクラスのために標準実装をしておくか、raiseなどでサブクラスにオーバーライドを促すようにする。
  2. それぞれのアルゴリズムごとに**テンプレートメソッド**をオーバーライドした**サブクラス**を作成する

実例:
  * WEBrick
  * initializeメソッド - 初期化の最後にinitializeを呼び出すようにしている



### ストラテジ<a name="strategy"></a>

目的/概要:

  * アルゴリズムに多様性をもたせたい場合に便利(テンプレートメソッドパターンと同様の問題に対する委譲ベースのアプローチ)
  * アルゴリズムのパターン（出力形式など）ごとにばらばらのオブジェクトとしてシンプルに実装する。
    (テンプレートメソッドは、アルゴリズム中の変わる部分を抜き出してサブクラスに押し込む)
  * 委譲と集約を使っているので、テンプレートメソッドパターンの継承に比べて、実行時にアルゴリズム(ストラテジ)を変更することが容易。

やり方:
  1. すべて同じことを実行するクラス群（ストラテジー）を定義する（例：フォーマット出力、図を作成など）
  2. クラス群に対して、同じインターフェイスを共有し、あるクラスからそのインターフェイスを呼び出す（委譲）ことで、ストラテジを取り替え可能になる

注意点:
  * コンテキストとストラテジオブジェクト間に誤ったインターフェイスを設計しないようにする。
  * コンテキストと1つめのストラテジの依存関係を強くしすぎて、2,3つめのストラテジを盛り込めないといった状況にならないようにする。

実例:
  * rdocユーティリティ - Ruby, C, FORTRANのソースからドキュメントを抜き出せるので、パーサがストラテジになっている。またriコマンドでHTML形式やXML形式など出力形式を選べる。これもストラテジ。



### オブサーバー<a name="observer"></a>

目的/概要:

  * あるコンポーネントの動きを監視するコンポーネントを作ることができる。
    Observableオブジェクト(発信元)で発生したイベントをObserverオブジェクト(受信先)が受け取り処理をする。
  * ニュースの配信元（Observableオブジェクト）とニュースの消費者側（Observerオブジェクト）の間にインターフェイスをつくることで、Observerパターンはニュースをスムーズに渡すことができます。

やり方:
  1. Observableクラス(発信元)に対して、`include Observable`を宣言し、通知したい箇所で`notify_observers`メソッドを呼び出す。
  2. Observerクラス(受信先)に`update`メソッドを実装する
  3. どこかの処理で、Observableインスタンスの`add_observer`メソッドを使い、Observerインスタンスを登録する。

注意点:
  * Observableインスタンスの更新の頻度とタイミングを見極めないのと、莫大な通知イベントが走ってしまう。

実例:
  * ActiveRecord::Observer - レコードの作成、読み込み、書き込み、削除がされるたびに通知をうけたい場合、after_create, after_updateなどオブザーバーを定義できます。



### コンポジット<a name="composite"></a>

目的/概要:
  * フォルダ階層、組織階層、GUIのレイアウトなど**階層構造**をなす構造を表すときに使える
    (大きなオブジェクトが小さな子オブジェクトから構成されていて、その子オブジェクトも更に小さな孫オブジェクトでできているというパターン)
  * 子を持たない単一のコンポーネントの「リーフ」、複数の子(コンポーネント)を持つ複合的なコンポーネントの「コンポジット」、そして、リーフとコンポジットで共通する箇所を持つベースとなるコンポーネントの「コンポーネント」という３つの要素が必要です


やり方:
  1. すべてのオブジェクトの共通のインターフェースの「コンポーネント」を作成する
  2. 「コンポーネント」を継承し、単純な構成要素の「リーフ」を作成する(子を持たないレベル)
  3. 「コンポーネント」を継承し、複数の子要素(リーフ/コンポジット)を持つ「コンポジット」を作成する(親子関係を管理する責務を持つ)

注意点:
  * ツリーの深さが1段しかない(コンポジットオブジェクトの子コンポーネントがすべてリーフオブジェクト)と想定しない。CompositeがCompositeを保持している可能性が十分にあるので、再帰的に呼び出すようにする

実例:
  * GUIライブラリ(FXRuby)


------

### Todo

  * 各デザインパターンのクラス図とそのときの挙動の流れを細くする。
  * わかりやすいように、「やり方」の各ステップの下にソースコードを記載し、最後に出力を記載したほうが良いかも。
